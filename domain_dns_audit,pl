#!/usr/bin/perl

use strict;
use warnings;
use utf8;
use open qw(:std :utf8);

use Net::LDAP;
use Net::LDAP::Util qw(ldap_error_text);
use Net::DNS;
use JSON::MaybeXS qw(encode_json decode_json);
use Log::Log4perl;
use POSIX qw(strftime);
use FindBin;
use File::Spec;
use Getopt::Long;
use Domain::PublicSuffix;
use Parallel::ForkManager;
use Time::Out qw(timeout);

# =========================
# Version / Konstanten
# =========================

my $VERSION             = '1.0.0';
my $SCRIPT_DIR          = $FindBin::Bin;
my $DEFAULT_CONFIG      = File::Spec->catfile($SCRIPT_DIR, 'domain_dns_audit.json');
my $DEFAULT_LDAP_CONFIG = File::Spec->catfile($SCRIPT_DIR, 'domain_dns_ldap.json');

# =========================
# CLI Optionen
# =========================

my $opt_config;
my $opt_ldap_config;
my $opt_debug    = 0;
my $opt_domain;
my $opt_help     = 0;
my $opt_dry_run  = 0;
my $opt_max_procs;
my $opt_version  = 0;

GetOptions(
    'config=s'      => \$opt_config,      # Pfad zur JSON Config (DNS/Checks)
    'ldap-config=s' => \$opt_ldap_config, # separates LDAP Config File (optional)
    'debug'         => \$opt_debug,       # Debug Logging aktivieren
    'domain=s'      => \$opt_domain,      # nur eine Domain prüfen
    'dry-run'       => \$opt_dry_run,     # kein JSON schreiben, nur Log + Exitcode
    'max-procs=i'   => \$opt_max_procs,   # Anzahl paralleler Prozesse
    'version'       => \$opt_version,     # Version ausgeben
    'help'          => \$opt_help,        # Hilfe anzeigen
) or die "Fehler beim Parsen der Optionen. Verwende --help für Hilfe.\n";

if ($opt_help) {
    print <<"USAGE";
Verwendung: $0 [--config FILE] [--ldap-config FILE] [--domain DOMAIN] [--debug]
                [--max-procs N] [--dry-run] [--version]

Optionen:
  --config FILE       Pfad zur JSON Konfiguration (Default: $DEFAULT_CONFIG)
                      (DNS, Domains, Checks, Output usw.)
  --ldap-config FILE  Separates JSON nur für LDAP (optional).
                      Default (falls vorhanden): $DEFAULT_LDAP_CONFIG
                      Entweder:
                        { "ldap": { ... } }  oder direkt { uri: ..., base_dn: ... }

  --domain DOMAIN     Nur diese eine Domain prüfen (LDAP/extra_domains werden ignoriert)
  --debug             Log Level DEBUG aktivieren

  --max-procs N       Anzahl paralleler Prozesse (Default: runtime.max_procs oder 20)
  --dry-run           Kein JSON-Report schreiben, nur Log / Exitcode
  --version           Version von domain_dns_audit anzeigen
  --help              Diese Hilfe anzeigen

Beispiele:
  $0
  $0 --config /etc/mmbb/domain_dns_audit.json
  $0 --config /etc/mmbb/domain_dns_audit.json --ldap-config /etc/mmbb/domain_dns_ldap.json
  $0 --domain example.ch --debug
  $0 --max-procs 10 --dry-run
USAGE
    exit 0;
}

if ($opt_version) {
    print "domain_dns_audit Version $VERSION\n";
    exit 0;
}

# =========================
# Konfiguration laden
# =========================

my $config_file = $opt_config // $DEFAULT_CONFIG;

open my $cfh, '<:utf8', $config_file
  or die "Kann Config nicht oeffnen: $config_file: $!";

local $/;
my $config_json = <$cfh>;
close $cfh;

my $conf = eval { decode_json($config_json) };
die "Fehler beim Parsen der JSON Config $config_file: $@" if $@;
die "Config $config_file ist kein JSON Objekt\n" unless ref $conf eq 'HASH';

# Haupt Config Bereiche
my $ldap_conf    = $conf->{ldap}    || {};
my $check_conf   = $conf->{check}   || {};
my $out_conf     = $conf->{output}  || {};
my $dns_conf     = $conf->{dns}     || {};
my $dom_conf     = $conf->{domains} || {};
my $runtime_conf = $conf->{runtime} || {};

# =========================
# Logging
# =========================

my $LOG_FILE  = $out_conf->{log_file}  || "/var/log/mmbb/domain_dns_audit.log";
my $JSON_FILE = $out_conf->{json_file} || "/var/log/mmbb/domain_dns_audit.json";
my $LOG_LEVEL = $out_conf->{log_level} || "INFO";

if ($opt_debug) {
    $LOG_LEVEL = "DEBUG";
}

my $log_conf = qq(
    log4perl.logger                    = $LOG_LEVEL, LOGFILE
    log4perl.appender.LOGFILE          = Log::Log4perl::Appender::File
    log4perl.appender.LOGFILE.filename = $LOG_FILE
    log4perl.appender.LOGFILE.layout   = Log::Log4perl::Layout::PatternLayout
    log4perl.appender.LOGFILE.layout.ConversionPattern = %d [%p] [%P] %m%n
    log4perl.appender.LOGFILE.binmode  = :encoding(UTF-8)
);

Log::Log4perl::init(\$log_conf);
my $log = Log::Log4perl->get_logger();

$log->info("Start domain_dns_audit Version $VERSION mit Config $config_file");
$log->info("CLI: debug=$opt_debug, domain=" . ($opt_domain // '') . ", dry_run=$opt_dry_run");

# =========================
# LDAP Config extern / Default
# =========================

my $ldap_config_file;

if (defined $opt_ldap_config) {
    $ldap_config_file = $opt_ldap_config;
    $log->info("LDAP Config per CLI gesetzt: $ldap_config_file");
} elsif (-e $DEFAULT_LDAP_CONFIG) {
    $ldap_config_file = $DEFAULT_LDAP_CONFIG;
    $log->info("Verwende Default LDAP Config: $ldap_config_file");
}

if ($ldap_config_file) {
    open my $lfh, '<:utf8', $ldap_config_file
      or die "Kann LDAP Config nicht oeffnen: $ldap_config_file: $!";

    local $/;
    my $ldap_json = <$lfh>;
    close $lfh;

    my $ldap_raw = eval { decode_json($ldap_json) };
    die "Fehler beim Parsen der LDAP Config $ldap_config_file: $@" if $@;
    die "LDAP Config $ldap_config_file ist kein JSON Objekt\n" unless ref $ldap_raw eq 'HASH';

    if (exists $ldap_raw->{ldap} && ref $ldap_raw->{ldap} eq 'HASH') {
        $ldap_conf = $ldap_raw->{ldap};
        $log->info("LDAP Config aus ldap Block uebernommen");
    } else {
        $ldap_conf = $ldap_raw;
        $log->info("LDAP Config aus Root Objekt uebernommen");
    }
} else {
    $log->info("Keine separate LDAP Config, nutze ldap Block aus Haupt Config");
}

# =========================
# Globale Settings aus Config
# =========================

my $suffix_handler = Domain::PublicSuffix->new();

sub _as_list {
    my ($val) = @_;
    return () unless defined $val;
    if (ref $val eq 'ARRAY') {
        return map { defined $_ ? $_ : () } @$val;
    } else {
        return map { s/^\s+|\s+$//gr } split /,/, $val;
    }
}

# LDAP optional / mehrere URIs moeglich
my @LDAP_URIS = _as_list($ldap_conf->{uri} // $ldap_conf->{uris});

my $LDAP_ENABLED;
if (exists $ldap_conf->{enabled}) {
    $LDAP_ENABLED = $ldap_conf->{enabled} ? 1 : 0;
} else {
    $LDAP_ENABLED = @LDAP_URIS ? 1 : 0;
}

$log->info(
    "LDAP_ENABLED = $LDAP_ENABLED"
    . (@LDAP_URIS ? " (URIs: " . join(", ", @LDAP_URIS) . ")" : "")
);

my $GLOBAL_REQUIRE_SPF  = exists $check_conf->{require_spf}
    ? ($check_conf->{require_spf} ? 1 : 0)
    : 1;

my $GLOBAL_REQUIRE_DKIM = exists $check_conf->{require_dkim}
    ? ($check_conf->{require_dkim} ? 1 : 0)
    : 1;

my @GLOBAL_DMARC_OK_POL  = _as_list($check_conf->{dmarc_ok_policies});
@GLOBAL_DMARC_OK_POL     = ("reject", "quarantine") unless @GLOBAL_DMARC_OK_POL;

my @GLOBAL_DKIM_SELECTORS             = _as_list($check_conf->{dkim_selectors});
my @GLOBAL_DKIM_TXT_REQUIRED_CONTAINS = _as_list($check_conf->{dkim_txt_required_contains});

my $GLOBAL_MX_POLICY    = $check_conf->{mx_policy}    || {};
my $GLOBAL_SPF_POLICY   = $check_conf->{spf_policy}   || {};
my $GLOBAL_DKIM_POLICY  = $check_conf->{dkim_policy}  || {};
my $GLOBAL_DMARC_POLICY = $check_conf->{dmarc_policy} || {};

# DNS Konfiguration aus JSON (mit Defaults)
my $DNS_TIMEOUT     = defined $dns_conf->{timeout}     ? $dns_conf->{timeout}     : 5;
my $DNS_UDP_TIMEOUT = defined $dns_conf->{udp_timeout} ? $dns_conf->{udp_timeout} : 2;
my $DNS_TCP_TIMEOUT = defined $dns_conf->{tcp_timeout} ? $dns_conf->{tcp_timeout} : 4;

my @DNS_SERVERS = _as_list($dns_conf->{servers});
if (@DNS_SERVERS) {
    $log->info(
        "DNS Server aus Config: " . join(", ", @DNS_SERVERS)
        . " (udp_timeout=$DNS_UDP_TIMEOUT, tcp_timeout=$DNS_TCP_TIMEOUT, alarm_timeout=$DNS_TIMEOUT)"
    );
} else {
    $log->info(
        "Kein DNS Server in Config, nutze System Resolver "
        . "(udp_timeout=$DNS_UDP_TIMEOUT, tcp_timeout=$DNS_TCP_TIMEOUT, alarm_timeout=$DNS_TIMEOUT)"
    );
}

my @EXTRA_DOMAINS   = map { lc $_ } _as_list($dom_conf->{extra_domains});
my @EXCLUDE_DOMAINS = map { lc $_ } _as_list($dom_conf->{exclude_domains});

my $PROFILE_CONF = $check_conf->{profiles} || {};

# Runtime / Parallelität
my $CONFIG_MAX_PROCS = $runtime_conf->{max_procs};
$CONFIG_MAX_PROCS = 20 unless defined $CONFIG_MAX_PROCS && $CONFIG_MAX_PROCS =~ /^\d+$/ && $CONFIG_MAX_PROCS > 0;

my $MAX_PROCS = defined $opt_max_procs && $opt_max_procs > 0 ? $opt_max_procs : $CONFIG_MAX_PROCS;
$log->info("Maximale parallele Prozesse: $MAX_PROCS (Config=" . $CONFIG_MAX_PROCS . ", CLI=" . ($opt_max_procs // 'undef') . ")");

# =========================
# DNS Resolver Konfiguration
# =========================

my %resolver_opts = (
    retry       => 2,
    udp_timeout => $DNS_UDP_TIMEOUT,
    tcp_timeout => $DNS_TCP_TIMEOUT,
);

if (@DNS_SERVERS) {
    $resolver_opts{nameservers} = \@DNS_SERVERS;
}

# =========================
# DNS Wrapper mit Timeout und Retries
# =========================

sub safe_dns_query {
    my ($resolver, $name, $type, $max_retries) = @_;
    $type        ||= 'A';
    $max_retries ||= 2;

    for my $attempt (1 .. $max_retries) {
        my $pkt;

        eval {
            timeout $DNS_TIMEOUT => sub {
                $pkt = $resolver->query($name, $type);
            };
        };

        if ($@) {
            if ($@ =~ /timeout/i) {
                $log->warn("[DNS] Timeout bei Query: $name ($type) Versuch $attempt");
            } else {
                $log->warn("[DNS] Fehler bei Query: $name ($type) Versuch $attempt: $@");
            }
            next;
        }

        return $pkt if $pkt;
    }

    $log->error("[DNS] Alle Versuche für $name ($type) fehlgeschlagen");
    return undef;
}

# =========================
# Hilfsfunktionen
# =========================

sub fetch_domains_from_ldap {
    my @uris = @LDAP_URIS;
    die "ldap.uri oder ldap.uris fehlt in LDAP Config\n" unless @uris;

    my $bind_dn     = $ldap_conf->{bind_dn}     || "";
    my $bind_pw     = $ldap_conf->{bind_pw}     || "";
    my $base_dn     = $ldap_conf->{base_dn}     || die "ldap.base_dn fehlt in LDAP Config\n";
    my $filter      = $ldap_conf->{filter}      || "(objectClass=*)";
    my $attr_domain = $ldap_conf->{attr_domain} || "associatedDomain";

    my $last_err;
    my $ldap;
    my $mesg;

    URI_LOOP:
    for my $uri (@uris) {
        $log->info("Versuche LDAP Server: $uri (BaseDN=$base_dn, Filter=$filter, Attr=$attr_domain)");

        $ldap = Net::LDAP->new($uri, timeout => 10);
        if (!$ldap) {
            $last_err = "LDAP Verbindung fehlgeschlagen zu $uri: $@ oder $!";
            $log->warn($last_err);
            next URI_LOOP;
        }

        if ($bind_dn) {
            $mesg = $ldap->bind($bind_dn, password => $bind_pw);
        } else {
            $mesg = $ldap->bind;
        }

        if ($mesg->code) {
            $last_err = "LDAP Bind Fehler auf $uri: " . ldap_error_text($mesg->code);
            $log->warn($last_err);
            $ldap->unbind;
            $ldap = undef;
            next URI_LOOP;
        }

        $log->info("LDAP Bind erfolgreich auf $uri");
        last URI_LOOP;
    }

    die "Keiner der LDAP Server erreichbar oder bindbar: $last_err\n"
        unless $ldap;

    $mesg = $ldap->search(
        base   => $base_dn,
        scope  => 'sub',
        filter => $filter,
        attrs  => [$attr_domain],
    );

    if ($mesg->code) {
        my $err = "LDAP Suche Fehler: " . ldap_error_text($mesg->code);
        $ldap->unbind;
        die "$err\n";
    }

    my %domains;
    foreach my $entry ($mesg->entries) {
        my @vals = $entry->get_value($attr_domain);
        for my $d (@vals) {
            next unless defined $d;
            $d =~ s/^\s+|\s+$//g;
            next unless $d;
            $d = lc $d;
            $domains{$d} = 1;
        }
    }

    $ldap->unbind;

    my @dom_list = sort keys %domains;
    $log->info("LDAP Domains gefunden: " . scalar(@dom_list));
    return @dom_list;
}

sub get_txt_records {
    my ($resolver, $name) = @_;
    my $pkt = safe_dns_query($resolver, $name, "TXT");
    return () unless $pkt;
    my @txt;
    foreach my $rr ($pkt->answer) {
        next unless $rr->type eq "TXT";
        push @txt, $rr->txtdata;
    }
    return @txt;
}

sub get_txt_records_with_cname {
    my ($resolver, $name) = @_;

    my @txt = get_txt_records($resolver, $name);
    if (@txt) {
        return {
            txt          => \@txt,
            cname_used   => 0,
            cname_target => undef,
        };
    }

    my $pkt = safe_dns_query($resolver, $name, "CNAME");
    return {
        txt          => [],
        cname_used   => 0,
        cname_target => undef,
    } unless $pkt;

    my ($cname_rr) = grep { $_->type eq 'CNAME' } $pkt->answer;
    return {
        txt          => [],
        cname_used   => 0,
        cname_target => undef,
    } unless $cname_rr;

    my $target = $cname_rr->cname;
    my @txt2 = get_txt_records($resolver, $target);

    return {
        txt          => \@txt2,
        cname_used   => 1,
        cname_target => $target,
    };
}

sub spf_mode_rank {
    my ($mode) = @_;
    return 4 if $mode eq 'hard';
    return 3 if $mode eq 'soft';
    return 2 if $mode eq 'neutral';
    return 2 if $mode eq 'no-all';
    return 1 if $mode eq 'open';
    return 0 if $mode eq 'none';
    return 0;
}

sub org_domain {
    my ($dom) = @_;
    return undef unless defined $dom;

    my $root = $suffix_handler->get_root_domain($dom);

    if (defined $root) {
        return $root;
    }

    my @p = split /\./, $dom;
    return join('.', @p[-2, -1]) if @p >= 2;
    return $dom;
}

# =========================
# DKIM Tag Parsing
# =========================

sub parse_dkim_tag_string {
    my ($s) = @_;
    my %tags;

    return \%tags unless defined $s;
    $s =~ s/^\s+|\s+$//g;
    return \%tags unless length $s;

    for my $chunk (split /;/, $s) {
        $chunk =~ s/^\s+|\s+$//g;
        next unless $chunk;

        my ($k, $v) = split /=/, $chunk, 2;
        next unless defined $k && defined $v;

        $k =~ s/^\s+|\s+$//g;
        $v =~ s/^\s+|\s+$//g;

        $k = lc $k;
        $v =~ s/\s+//g;

        $tags{$k} = $v;
    }

    return \%tags;
}

sub dkim_txt_matches_expected {
    my ($effective, $expected) = @_;

    return 0 unless defined $effective && defined $expected;

    my $eff_tags = parse_dkim_tag_string($effective);
    my $exp_tags = parse_dkim_tag_string($expected);

    for my $k (keys %{$exp_tags}) {
        return 0 unless exists $eff_tags->{$k};
        return 0 unless $eff_tags->{$k} eq $exp_tags->{$k};
    }

    return 1;
}

# =========================
# DKIM RFC Analyse
# =========================

sub analyze_dkim_rfc {
    my ($txt_combined) = @_;

    my $tags = parse_dkim_tag_string($txt_combined);
    my @warnings;
    my $status = "ok";

    # v Tag prüfen
    if (!defined $tags->{v} || lc($tags->{v}) ne 'dkim1') {
        $status = "fail";
        push @warnings, "DKIM v Tag fehlt oder ist nicht 'DKIM1'";
    }

    # p Tag prüfen
    if (!defined $tags->{p} || $tags->{p} eq '') {
        $status = "fail";
        push @warnings, "DKIM p Tag fehlt oder ist leer (Schluessel deaktiviert)";
    }

    # k Tag prüfen, falls vorhanden
    if (defined $tags->{k}) {
        my $k = lc $tags->{k};
        if ($k ne 'rsa' && $k ne 'ed25519') {
            push @warnings, "Unbekannter DKIM k Parameter: $k";
        }
    }

    # t Flag (Testmodus)
    if (defined $tags->{t} && $tags->{t} =~ /y/) {
        push @warnings, "DKIM t Flag enthaelt 'y' (Testmodus)";
    }

    return {
        status   => $status,
        warnings => \@warnings,
        tags     => $tags,
    };
}

# =========================
# MX Check
# =========================

sub check_mx {
    my ($resolver, $domain, $mx_policy) = @_;

    my $pkt = safe_dns_query($resolver, $domain, "MX");
    my @mx_hosts;

    if ($pkt) {
        foreach my $rr ($pkt->answer) {
            next unless $rr->type eq "MX";
            push @mx_hosts, {
                exchange   => lc($rr->exchange),
                preference => $rr->preference,
            };
        }
    }

    my @actual_names = map { $_->{exchange} } @mx_hosts;
    my $groups_conf  = $mx_policy->{groups} || [];
    my @groups       = ref $groups_conf eq 'ARRAY' ? @$groups_conf : ();

    if (!@mx_hosts) {
        return {
            status => "fail",
            detail => "Keine MX Records gefunden",
            mx     => \@mx_hosts,
            groups => \@groups,
        };
    }

    if (!@groups) {
        return {
            status => "ok",
            detail => "MX Records gefunden: " . join(", ", @actual_names),
            mx     => \@mx_hosts,
            groups => [],
        };
    }

    my $overall_status = "fail";
    my @group_results;

    for my $g (@groups) {
        my @req = map { lc $_ } _as_list($g->{mx_required});
        my $allow_others = exists $g->{mx_allow_others} ? ($g->{mx_allow_others} ? 1 : 0) : 1;

        my %actual_set   = map { $_ => 1 } @actual_names;
        my %required_set = map { $_ => 1 } @req;

        my @missing;
        my @unexpected;

        for my $r (@req) {
            push @missing, $r unless $actual_set{$r};
        }

        if (@req) {
            for my $a (@actual_names) {
                push @unexpected, $a unless $required_set{$a};
            }
        }

        my $st = "ok";
        my @parts;

        push @parts, "MX Records: " . join(", ", @actual_names);

        if (@missing) {
            $st = "fail";
            push @parts, "fehlende MX: " . join(", ", @missing);
        }

        if (@unexpected) {
            if ($allow_others) {
                push @parts, "zusaetzliche MX erlaubt: " . join(", ", @unexpected);
            } else {
                $st = "fail";
                push @parts, "unerwartete MX: " . join(", ", @unexpected);
            }
        }

        push @group_results, {
            name             => $g->{name} // '',
            status           => $st,
            mx_required      => \@req,
            missing_required => \@missing,
            unexpected       => \@unexpected,
            mx_allow_others  => $allow_others + 0,
            detail           => join("; ", @parts),
        };

        if ($st eq 'ok' && $overall_status ne 'ok') {
            $overall_status = 'ok';
        }
    }

    my $detail = $overall_status eq 'ok'
        ? "MX Konfiguration entspricht mindestens einem Profil"
        : "Keine MX Profilgruppe wurde vollstaendig erfuellt";

    return {
        status => $overall_status,
        detail => $detail,
        mx     => \@mx_hosts,
        groups => \@group_results,
    };
}

# =========================
# SPF Deep Analysis (RFC 7208)
# =========================

sub analyze_spf_recursion {
    my ($resolver, $domain, $stats, $seen) = @_;
    
    # $stats = { lookups => 0, void_lookups => 0, warnings => [], path => [] }
    # $seen  = { domain => 1 } (Loop Prevention)

    # Loop Detection
    if ($seen->{$domain}) {
        push @{$stats->{warnings}}, "SPF Loop entdeckt bei Domain: $domain";
        return;
    }
    $seen->{$domain} = 1;
    push @{$stats->{path}}, $domain;

    # Rekursions Tiefe Sicherheit
    if (scalar(@{$stats->{path}}) > 10) {
        push @{$stats->{warnings}}, "SPF Rekursion zu tief (>10 Ebenen) bei $domain";
        return;
    }

    my @txt = get_txt_records($resolver, $domain);
    my @spf_records = grep { /^v=spf1(\s|$)/i } @txt;

    if (!@spf_records) {
        return;
    }
    
    # RFC 7208: Es darf nur ein SPF Record existieren
    if (@spf_records > 1) {
         push @{$stats->{warnings}}, "Mehrere SPF Records gefunden bei $domain";
         return;
    }

    my $spf_string = $spf_records[0];
    my @terms = split /\s+/, $spf_string;
    
    foreach my $term (@terms) {
        next if $term =~ /^v=spf1$/i;
        next unless $term;

        my $clean_term = $term;
        $clean_term =~ s/^[\+\-\~\?]//;
        
        if ($clean_term =~ /^include:(.*)/i) {
            $stats->{lookups}++;
            my $target = $1;
            analyze_spf_recursion($resolver, $target, $stats, { %$seen });
        }
        elsif ($clean_term =~ /^redirect=(.*)/i) {
            $stats->{lookups}++;
            my $target = $1;
            analyze_spf_recursion($resolver, $target, $stats, $seen);
            last;
        }
        elsif ($clean_term =~ /^(?:a|mx|ptr|exists)(?:[:\/]|$)/i) {
            $stats->{lookups}++;
        }
    }
}

sub check_spf {
    my ($resolver, $domain, $profile, $global_spf_policy) = @_;

    my $spf_policy  = $profile->{spf_policy} || $global_spf_policy || {};
    my $require_spf = exists $profile->{require_spf}
        ? ($profile->{require_spf} ? 1 : 0)
        : $GLOBAL_REQUIRE_SPF;

    # 1. Basis Check: Record holen
    my @txt = get_txt_records($resolver, $domain);
    my @spf_all = grep { /^v=spf1(\s|$)/i } @txt;

    my $spf_orig = @spf_all ? $spf_all[0] : "";
    my $mode;
    my $has_all = 0;
    
    if (!@spf_all) {
        $mode = "none";
    } elsif ($spf_orig =~ /-all\b/i) {
        $mode = "hard"; $has_all = 1;
    } elsif ($spf_orig =~ /~all\b/i) {
        $mode = "soft"; $has_all = 1;
    } elsif ($spf_orig =~ /\?all\b/i) {
        $mode = "neutral"; $has_all = 1;
    } elsif ($spf_orig =~ /\ball\b/i) {
        $mode = "open"; $has_all = 1;
    } elsif ($spf_orig =~ /redirect=/i) {
        $mode = "redirect";
    } else {
        $mode = "no-all";
    }

    # 2. Deep Analysis (RFC 7208 Lookup Count & Recursion)
    my $analysis_stats = {
        lookups  => 0,
        warnings => [],
        path     => [],
    };
    
    if (@spf_all) {
        analyze_spf_recursion($resolver, $domain, $analysis_stats, {});
    }

    # 3. Profil Prüfung (Gruppen)
    my $groups_conf   = $spf_policy->{groups}   || {};
    my $defaults_conf = $spf_policy->{defaults} || {};
    my @groups        = ref $groups_conf eq 'ARRAY' ? @$groups_conf : ();
    
    my $status;
    my $detail;
    my @group_results;
    my @notes;

    if ($analysis_stats->{lookups} > 10) {
        push @notes, "CRITICAL: SPF Lookup Limit ueberschritten (" . $analysis_stats->{lookups} . " > 10). SPF ist ungueltig (PermError)";
    }
    if (@{$analysis_stats->{warnings}}) {
        push @notes, "SPF Struktur Warnungen: " . join("; ", @{$analysis_stats->{warnings}});
    }

    if (!@spf_all && !@groups) {
        if ($require_spf) {
            $status = "fail";
            $detail = "Kein SPF Record vorhanden (require_spf=1)";
        } else {
            $status = "warn";
            $detail = "Kein SPF Record vorhanden (require_spf=0)";
        }
    } elsif (@groups) {
        my $overall_status = "fail";
        
        for my $g (@groups) {
            my @allowed_modes = _as_list(exists $g->{allowed_modes} ? $g->{allowed_modes} : $defaults_conf->{allowed_modes});
            my %allowed = map { $_ => 1 } @allowed_modes;
            my @req_parts = _as_list($g->{required_contains});
            
            my $gst = "ok";
            my @g_notes;
            
            if (@allowed_modes && !$allowed{$mode} && $mode ne 'redirect') {
                $gst = "fail";
                push @g_notes, "Modus $mode nicht erlaubt";
            }
            
            for my $p (@req_parts) {
                if (index($spf_orig, $p) < 0) {
                     $gst = "fail";
                     push @g_notes, "Fehlt: $p";
                }
            }
            
            push @group_results, {
                name   => $g->{name},
                status => $gst,
                detail => join("; ", @g_notes),
            };
            
            if ($gst eq 'ok' && $overall_status ne 'ok') {
                $overall_status = 'ok';
            }
        }
        $status = $overall_status;
        $detail = "SPF Profil Check (Modus $mode)";
    } else {
        $status = "ok";
        $detail = "SPF vorhanden (Modus $mode)";
        if ($mode eq 'open' && $defaults_conf->{forbid_open}) {
            $status = "fail";
            $detail = "SPF Modus open verboten";
        }
    }

    if ($analysis_stats->{lookups} > 10) {
        $status = "fail";
        $detail .= " [RFC VIOLATION: >10 Lookups]";
    }

    if (@notes) {
        $detail .= " (" . join("; ", @notes) . ")";
    }

    return {
        status       => $status,
        detail       => $detail,
        require_spf  => $require_spf + 0,
        raw_original => \@spf_all,
        mode         => $mode,
        rfc_analysis => $analysis_stats,
        groups       => \@group_results,
    };
}

# =========================
# DMARC Check
# =========================

sub parse_dmarc_tag {
    my ($tagstr) = @_;
    my %tags;
    for my $p (split /;/, $tagstr) {
        $p =~ s/^\s+|\s+$//g;
        next unless $p;
        my ($k, $v) = split /=/, $p, 2;
        next unless defined $k and defined $v;
        $k =~ s/^\s+|\s+$//g;
        $v =~ s/^\s+|\s+$//g;
        $tags{lc $k} = $v;
    }
    return %tags;
}

sub extract_domain_from_mailto {
    my ($uri) = @_;
    return undef unless $uri;
    $uri =~ s/^\s+|\s+$//g;
    return undef unless $uri =~ /^mailto:/i;
    my ($addr) = $uri =~ /^mailto:([^?]+)/i;
    return undef unless $addr && $addr =~ /\@/;
    my (undef, $dom) = split /\@/, $addr, 2;
    $dom = lc $dom if defined $dom;
    return $dom;
}

sub check_external_dmarc_authorization {
    my ($resolver, $domain, $provider_domain) = @_;
    my $name = $domain . "._report._dmarc." . $provider_domain;
    my @txt = get_txt_records($resolver, $name);

    my $authorized = 0;
    for my $t (@txt) {
        if ($t =~ /v=DMARC1/i) {
            $authorized = 1;
            last;
        }
    }

    return {
        fqdn        => $name,
        authorized  => $authorized ? 1 : 0,
        txt_records => \@txt,
    };
}

sub check_dmarc {
    my ($resolver, $domain, $profile, $global_dmarc_policy) = @_;

    my $dmarc_policy = $profile->{dmarc_policy} || $global_dmarc_policy || {};

    my @ok_policies = _as_list($dmarc_policy->{ok_policies});
    @ok_policies = _as_list($profile->{dmarc_ok_policies}) unless @ok_policies;
    @ok_policies = @GLOBAL_DMARC_OK_POL                     unless @ok_policies;

    my $lookup_domain   = $domain;
    my $inherited_from  = undef;

    my $name = "_dmarc.$lookup_domain";
    my @txt  = get_txt_records($resolver, $name);
    my @dmarc = grep { /^v=DMARC1/i } @txt;

    my $org_dom = org_domain($domain);

    if (!@dmarc && defined $org_dom && $org_dom ne $domain) {

        my $parent_name = "_dmarc.$org_dom";
        my @txt_parent  = get_txt_records($resolver, $parent_name);
        my @dmarc_parent = grep { /^v=DMARC1/i } @txt_parent;

        if (@dmarc_parent) {
            $lookup_domain  = $org_dom;
            $inherited_from = $org_dom;
            @txt            = @txt_parent;
            @dmarc          = @dmarc_parent;
        }
    }

    if (!@dmarc) {
        return {
            status           => "fail",
            detail           => "Kein DMARC Record gefunden",
            raw              => \@txt,
            inherited_from   => undef,
            effective_domain => $lookup_domain,
        };
    }

    my %tags   = parse_dmarc_tag($dmarc[0]);
    my $policy = lc($tags{p} // "");

    my $policy_ok = 0;
    for my $pol (@ok_policies) {
        if ($policy eq $pol) {
            $policy_ok = 1;
            last;
        }
    }

    my $rua         = $tags{rua} // "";
    my $require_rua = exists $dmarc_policy->{require_rua}
        ? ($dmarc_policy->{require_rua} ? 1 : 0)
        : 1;

    my @rua_raw = split /,/, $rua;
    my @rua_domains;
    for my $r (@rua_raw) {
        my $d = extract_domain_from_mailto($r);
        push @rua_domains, $d if $d;
    }

    my @allow_external = map { lc $_ } _as_list($dmarc_policy->{allow_external_rua_domains});
    my %allow_external = map { $_ => 1 } @allow_external;

    my $require_auth = exists $dmarc_policy->{require_external_authorization}
        ? ($dmarc_policy->{require_external_authorization} ? 1 : 0)
        : 0;

    my @local_rua;
    my @external_domains;
    my %external_seen;

    my $org_lookup = org_domain($lookup_domain);

    for my $rd (@rua_domains) {
        next unless $rd;
        my $rua_org = org_domain($rd);

        if (defined $rua_org && defined $org_lookup && $rua_org eq $org_lookup) {
            push @local_rua, $rd;
        } else {
            push @external_domains, $rd unless $external_seen{$rd}++;
        }
    }

    my @external_details;
    my @external_allowed;
    my @external_unapproved;

    for my $ext (@external_domains) {

        my $auth_info = check_external_dmarc_authorization($resolver, $lookup_domain, $ext);
        my $in_allow  = $allow_external{$ext} ? 1 : 0;

        push @external_details, {
            domain              => $ext,
            in_allowlist        => $in_allow,
            authorized_via_dns  => $auth_info->{authorized},
            auth_fqdn           => $auth_info->{fqdn},
            auth_txt            => $auth_info->{txt_records},
        };

        if ($in_allow) {
            push @external_allowed, $ext;
        } else {
            push @external_unapproved, $ext;
        }
    }

    my $status = "ok";
    my @notes;

    if (!$policy_ok) {
        $status = "warn";
        push @notes, "DMARC Policy ist nicht streng (" . ($policy || "keine") . ")";
    }

    if ($require_rua && !@rua_domains) {
        $status = "warn" if $status eq "ok";
        push @notes, "Kein RUA Reporting konfiguriert, obwohl require_rua=1";
    }

    if ($require_auth) {

        if (@external_unapproved) {
            $status = "warn" if $status eq "ok";
            push @notes,
                "RUA nutzt nicht freigegebene externe Domains: "
                . join(", ", @external_unapproved);
        }

        my @not_authorized = grep {
            my $d = $_;
            my ($det) = grep { $_->{domain} eq $d } @external_details;
            $det && !$det->{authorized_via_dns}
        } @external_domains;

        if (@not_authorized) {
            $status = "warn" if $status eq "ok";
            push @notes,
                "Externe RUA Domains ohne _report._dmarc Autorisierung: "
                . join(", ", @not_authorized);
        }
    }

    my $detail = "DMARC ok";
    $detail .= " (" . join(", ", @notes) . ")" if @notes;

    return {
        status           => $status,
        detail           => $detail,
        raw              => \@dmarc,
        tags             => \%tags,
        inherited_from   => $inherited_from,
        effective_domain => $lookup_domain,
        rua_analysis     => {
            rua_raw                        => \@rua_raw,
            rua_domains                    => \@rua_domains,
            local_rua                      => \@local_rua,
            external_domains               => \@external_domains,
            external_allowed               => \@external_allowed,
            external_unapproved            => \@external_unapproved,
            require_rua                    => $require_rua + 0,
            allowed_external_domains       => \@allow_external,
            require_external_authorization => $require_auth + 0,
            external_details               => \@external_details,
        },
    };
}

# =========================
# DKIM Check (mit RFC Analyse)
# =========================

sub check_dkim {
    my ($resolver, $domain, $profile, $global_dkim_policy) = @_;

    my $dkim_policy  = $profile->{dkim_policy} || $global_dkim_policy || {};

    my $require_dkim = exists $profile->{require_dkim}
        ? ($profile->{require_dkim} ? 1 : 0)
        : $GLOBAL_REQUIRE_DKIM;

    my @dkim_selectors = _as_list($dkim_policy->{selectors});
    @dkim_selectors = _as_list($profile->{dkim_selectors}) unless @dkim_selectors;
    @dkim_selectors = @GLOBAL_DKIM_SELECTORS               unless @dkim_selectors;

    if (!@dkim_selectors) {
        return {
            status => "warn",
            detail => "Keine DKIM Selector in Profil oder global definiert, Pruefung uebersprungen",
        };
    }

    my @dkim_required = _as_list($dkim_policy->{txt_required_contains});
    @dkim_required = _as_list($profile->{dkim_txt_required_contains}) unless @dkim_required;
    @dkim_required = @GLOBAL_DKIM_TXT_REQUIRED_CONTAINS               unless @dkim_required;

    my $mode = $dkim_policy->{evaluation_mode} || 'any_ok';
    $mode = 'any_ok' unless $mode =~ /^(any_ok|all_ok)$/;

    my $groups_conf = $dkim_policy->{groups} || [];
    my @groups      = ref $groups_conf eq 'ARRAY' ? @$groups_conf : ();

    my $expected_map = $dkim_policy->{expected_txt} || {};

    my %sel_results;
    my @statuses;

    for my $sel (@dkim_selectors) {
        my $name = $sel . "._domainkey.$domain";

        my $res = get_txt_records_with_cname($resolver, $name);
        my @txt          = @{ $res->{txt}          || [] };
        my $cname_used   = $res->{cname_used}   ? 1 : 0;
        my $cname_target = $res->{cname_target} || undef;

        my @dkim = grep { /^v=DKIM1/i } @txt;

        my $st;

        if (!@dkim) {
            $st = {
                status       => "fail",
                detail       => "Kein DKIM Record fuer Selector $sel (TXT oder CNAME Ziel)",
                raw          => \@txt,
                cname_used   => $cname_used,
                cname_target => $cname_target,
                groups       => [],
            };
        } else {
            my $txt_combined = join(" ", @dkim);

            my $sel_status = "ok";
            my @group_results;

            if (@groups) {
                my $any_ok = 0;

                for my $g (@groups) {
                    my @req = _as_list($g->{required_contains});
                    my @missing;

                    for my $p (@req) {
                        push @missing, $p unless index($txt_combined, $p) >= 0;
                    }

                    my $gst = @missing ? "fail" : "ok";
                    $any_ok ||= ($gst eq 'ok');

                    push @group_results, {
                        name                   => $g->{name} // '',
                        status                 => $gst,
                        required_contains      => \@req,
                        missing_required_parts => \@missing,
                    };
                }

                if ($mode eq 'any_ok') {
                    $sel_status = $any_ok ? "ok" : "fail";
                } else {
                    if (grep { $_->{status} eq 'fail' } @group_results) {
                        $sel_status = "fail";
                    } else {
                        $sel_status = "ok";
                    }
                }
            } else {
                my @missing_parts;
                if (@dkim_required) {
                    for my $part (@dkim_required) {
                        push @missing_parts, $part unless index($txt_combined, $part) >= 0;
                    }
                }

                if (@missing_parts) {
                    if ($require_dkim) {
                        $sel_status = "fail";
                    } else {
                        $sel_status = "warn";
                    }
                }

                @group_results = ({
                    name                   => 'required_parts',
                    status                 => @missing_parts ? ($require_dkim ? 'fail' : 'warn') : 'ok',
                    required_contains      => \@dkim_required,
                    missing_required_parts => \@missing_parts,
                });
            }

            # RFC Analyse einbauen
            my $rfc = analyze_dkim_rfc($txt_combined);

            if ($rfc->{status} eq 'fail') {
                $sel_status = 'fail' if $sel_status ne 'fail';
            }

            my @notes;

            my $expected_val = $expected_map->{$sel};
            if (defined $expected_val && $expected_val ne '') {
                if (!dkim_txt_matches_expected($txt_combined, $expected_val)) {
                    if ($require_dkim && $sel_status ne 'fail') {
                        $sel_status = 'fail';
                    } elsif (!$require_dkim && $sel_status eq 'ok') {
                        $sel_status = 'warn';
                    }
                    push @notes, "DKIM TXT fuer Selector $sel entspricht nicht dem erwarteten Wert aus Config (Tag Vergleich)";
                } else {
                    push @notes, "DKIM TXT fuer Selector $sel stimmt mit erwartetem Wert aus Config ueberein (Tag Vergleich)";
                }
            }

            if ($cname_used && $cname_target) {
                push @notes, "DKIM TXT via CNAME Ziel $cname_target";
            }

            if (@{ $rfc->{warnings} }) {
                push @notes, "DKIM RFC Hinweise: " . join("; ", @{ $rfc->{warnings} });
            }

            my $detail = @notes ? join("; ", @notes) : "DKIM Record fuer Selector $sel gefunden";

            $st = {
                status       => $sel_status,
                detail       => $detail,
                raw          => \@dkim,
                cname_used   => $cname_used,
                cname_target => $cname_target,
                groups       => \@group_results,
                rfc_analysis => $rfc,
            };
        }

        $sel_results{$sel} = $st;
        push @statuses, $st->{status};
    }

    my $overall_status;

    if ($mode eq 'all_ok') {
        if (grep { $_ eq 'fail' } @statuses) {
            $overall_status = 'fail';
        } elsif (grep { $_ eq 'warn' } @statuses) {
            $overall_status = 'warn';
        } else {
            $overall_status = 'ok';
        }
    } else {
        if (grep { $_ eq 'ok' } @statuses) {
            $overall_status = 'ok';
        } elsif (grep { $_ eq 'warn' } @statuses) {
            $overall_status = 'warn';
        } else {
            $overall_status = 'fail';
        }
    }

    if ($overall_status eq "fail" and !$require_dkim) {
        $overall_status = "warn";
    }

    my $detail = "DKIM Pruefung abgeschlossen (require_dkim=$require_dkim, mode=$mode)";

    return {
        status          => $overall_status,
        detail          => $detail,
        selectors       => \%sel_results,
        require_dkim    => $require_dkim + 0,
        required_parts  => \@dkim_required,
        evaluation_mode => $mode,
    };
}

# =========================
# Domain Verarbeitung
# =========================

sub process_domain {
    my ($dom, $resolver) = @_;

    $log->info("Pruefe Domain: $dom");

    my $dom_result;

    eval {
        my %profile_results;
        my $best_profile;
        my $best_status = 'fail';

        for my $pname (sort keys %{$PROFILE_CONF}) {
            my $p = $PROFILE_CONF->{$pname} || {};

            my $mx    = check_mx($resolver, $dom,    $p->{mx_policy}   || $GLOBAL_MX_POLICY);
            my $spf   = check_spf($resolver, $dom,   $p, $GLOBAL_SPF_POLICY);
            my $dmarc = check_dmarc($resolver, $dom, $p, $GLOBAL_DMARC_POLICY);
            my $dkim  = check_dkim($resolver, $dom,  $p, $GLOBAL_DKIM_POLICY);

            my @st = map { $_->{status} } ($mx, $spf, $dmarc, $dkim);

            my $profile_status = "ok";
            if (grep { $_ eq "fail" } @st) {
                $profile_status = "fail";
            } elsif (grep { $_ eq "warn" } @st) {
                $profile_status = "warn";
            }

            $profile_results{$pname} = {
                status => $profile_status,
                checks => {
                    mx    => $mx,
                    spf   => $spf,
                    dmarc => $dmarc,
                    dkim  => $dkim,
                },
            };

            if ($profile_status eq 'ok') {
                if ($best_status ne 'ok') {
                    $best_status  = 'ok';
                    $best_profile = $pname;
                }
            } elsif ($profile_status eq 'warn') {
                if ($best_status eq 'fail') {
                    $best_status  = 'warn';
                    $best_profile = $pname;
                }
            } elsif (!$best_profile) {
                $best_status  = 'fail';
                $best_profile = $pname;
            }
        }

        my $dom_status = $best_status || 'fail';

        $dom_result = {
            domain              => $dom,
            status              => $dom_status,
            best_profile        => $best_profile,
            best_profile_status => $best_status,
            profiles            => \%profile_results,
        };

        1;
    } or do {
        my $err = $@ || 'Unbekannter Fehler';
        $log->error("Fehler bei Domain $dom: $err");

        $dom_result = {
            domain => $dom,
            status => 'fail',
            error  => "$err",
        };
    };

    return $dom_result;
}

# =========================
# Hauptlogik mit Parallel::ForkManager
# =========================

my @domains;

if ($opt_domain) {
    @domains = (lc $opt_domain);
    $log->info("Nur Single Domain Modus aktiv: $opt_domain");
} else {
    if ($LDAP_ENABLED) {
        @domains = eval { fetch_domains_from_ldap() };
        if ($@) {
            $log->error("Fehler beim LDAP Abruf: $@");
            print STDERR "Fehler beim LDAP Abruf: $@\n";
            exit 1;
        }
    } else {
        $log->info("LDAP ist deaktiviert, verwende nur extra_domains");
        @domains = ();
    }

    push @domains, @EXTRA_DOMAINS if @EXTRA_DOMAINS;

    my %seen;
    @domains = grep { !$seen{$_}++ } @domains;

    if (@EXCLUDE_DOMAINS) {
        my %excl = map { $_ => 1 } @EXCLUDE_DOMAINS;
        my @before = @domains;
        @domains = grep { !$excl{$_} } @domains;

        my @removed = grep { $excl{$_} } @before;
        if (@removed) {
            $log->info("Ausgeschlossene Domains: " . join(", ", @removed));
        }
    }
}

if (!@domains) {
    $log->warn("Keine Domains zu pruefen nach Exclude Filter oder CLI Auswahl");
}

my @results;

my $pm = Parallel::ForkManager->new($MAX_PROCS);

$pm->run_on_finish(
    sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_ref) = @_;
        if ($data_ref && ref $data_ref eq 'HASH') {
            push @results, $data_ref;
        }
    }
);

for my $dom (@domains) {
    $pm->start and next;

    my $child_resolver = Net::DNS::Resolver->new(%resolver_opts);
    $child_resolver->persistent_udp(1);
    $child_resolver->persistent_tcp(1);

    my $dom_result = process_domain($dom, $child_resolver);

    $pm->finish(0, $dom_result);
}

$pm->wait_all_children;

@results = sort {
    (lc($a->{domain} // '')) cmp (lc($b->{domain} // ''))
} @results;

my $global_status = "ok";

for my $dom_result (@results) {
    my $dom_status = $dom_result->{status} // 'fail';

    if ($dom_status eq "fail") {
        $global_status = "fail";
        last;
    } elsif ($dom_status eq "warn" and $global_status eq "ok") {
        $global_status = "warn";
    }
}

my $summary = {
    timestamp     => strftime("%Y-%m-%dT%H:%M:%S", localtime),
    config_file   => $config_file,
    tool_version  => $VERSION,
    global_status => $global_status,
    domains_total => scalar(@domains),
    results       => \@results,
};

if ($opt_dry_run) {
    $log->info("Dry-Run aktiv: JSON Report wird NICHT geschrieben (global_status=$global_status)");
} else {
    eval {
        my $json = encode_json($summary);
        my ($vol, $dir, undef) = File::Spec->splitpath($JSON_FILE);
        my $path_dir = File::Spec->catpath($vol, $dir, "");
        if ($path_dir && !-d $path_dir) {
            mkdir $path_dir or die "Kann Verzeichnis nicht erstellen: $path_dir: $!";
        }
        open my $fh, ">:encoding(UTF-8)", $JSON_FILE
          or die "Kann JSON File nicht schreiben: $JSON_FILE: $!";
        print {$fh} $json or die "Fehler beim Schreiben in $JSON_FILE: $!";
        close $fh or warn "Fehler beim Schliessen von $JSON_FILE: $!";
        $log->info("JSON Report nach $JSON_FILE geschrieben");
    };
    if ($@) {
        $log->error("Fehler beim Schreiben des JSON Reports: $@");
    }
}

$log->info("Fertig, globaler Status: $global_status (Version $VERSION)");
print "domain_dns_audit v$VERSION: $global_status (Domains: " . scalar(@domains) . ")\n";

if ($global_status eq "ok") {
    exit 0;
} elsif ($global_status eq "warn") {
    exit 1;
} else {
    exit 2;
}
